# Squash Command Workflow
#
# This workflow is triggered by the /squash slash command from the slash.yml workflow.
# It squashes all commits on a PR branch into a single commit and force pushes the result.
#
# Usage: Comment `/squash` on a pull request
#
# Security Notes:
# - Only users with "write" permission can trigger this command (enforced in slash.yml)
# - Supports fork PRs when "Allow edits from maintainers" is enabled
# - Uses CHATOPS_TOKEN to push to branches
# - Uses --force-with-lease for safe force pushing
#
# To use this in a repo:
#
# name: Squash Command
# on:
#   repository_dispatch:
#     types: [squash-command]
#
# jobs:
#   squash:
#     name: Squash PR
#     uses: tektoncd/plumbing/.github/workflows/_squash-command.yaml@main
#     secrets:
#       CHATOPS_TOKEN: ${{ secrets.CHATOPS_TOKEN }}

name: Squash Command

on:
  workflow_call:
    secrets:
      CHATOPS_TOKEN:
        required: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  squash:
    runs-on: ubuntu-latest
    steps:
      - name: Add reaction to trigger comment
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        with:
          token: ${{ secrets.CHATOPS_TOKEN }}
          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}
          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}
          reactions: "+1"

      - name: Validate PR state
        id: validate
        env:
          GH_TOKEN: ${{ secrets.CHATOPS_TOKEN }}
          PR_NUMBER: ${{ github.event.client_payload.pull_request.number }}
          REPO: ${{ github.repository }}
          REPO_OWNER: ${{ github.repository_owner }}
        run: |
          # Get PR information
          echo "Fetching PR #$PR_NUMBER information..."
          PR_DATA=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json state,headRefName,baseRefName,headRepository,headRepositoryOwner,maintainerCanModify) || {
            echo "error=true" >> $GITHUB_OUTPUT
            echo "message=Failed to fetch PR information" >> $GITHUB_OUTPUT
            exit 0
          }

          PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
          if [ "$PR_STATE" != "OPEN" ]; then
            echo "error=true" >> $GITHUB_OUTPUT
            echo "message=PR #$PR_NUMBER is not open (state: $PR_STATE). Can only squash open PRs." >> $GITHUB_OUTPUT
            exit 0
          fi

          HEAD_REF=$(echo "$PR_DATA" | jq -r '.headRefName')
          BASE_REF=$(echo "$PR_DATA" | jq -r '.baseRefName')
          HEAD_REPO_OWNER=$(echo "$PR_DATA" | jq -r '.headRepositoryOwner.login')
          HEAD_REPO_NAME=$(echo "$PR_DATA" | jq -r '.headRepository.name')
          HEAD_REPO_FULL_NAME="${HEAD_REPO_OWNER}/${HEAD_REPO_NAME}"

          # Detect fork PRs and check maintainer push access
          if [ "$HEAD_REPO_OWNER" != "$REPO_OWNER" ]; then
            MAINTAINER_CAN_MODIFY=$(echo "$PR_DATA" | jq -r '.maintainerCanModify')
            if [ "$MAINTAINER_CAN_MODIFY" != "true" ]; then
              echo "error=true" >> $GITHUB_OUTPUT
              echo "message=Cannot squash fork PRs unless \"Allow edits from maintainers\" is enabled. Please ask the PR author to enable this option in the PR settings." >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "is_fork=true" >> $GITHUB_OUTPUT
            echo "Fork PR detected (head: $HEAD_REPO_FULL_NAME). Maintainer push access confirmed."
          else
            echo "is_fork=false" >> $GITHUB_OUTPUT
          fi

          echo "head_ref=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "base_ref=$BASE_REF" >> $GITHUB_OUTPUT
          echo "head_repo_full_name=$HEAD_REPO_FULL_NAME" >> $GITHUB_OUTPUT
          echo "error=false" >> $GITHUB_OUTPUT

          echo "PR #$PR_NUMBER: squashing '$HEAD_REF' (base: '$BASE_REF')"

      - name: Comment on validation error
        if: steps.validate.outputs.error == 'true'
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        with:
          token: ${{ secrets.CHATOPS_TOKEN }}
          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}
          issue-number: ${{ github.event.client_payload.github.payload.issue.number }}
          body: |
            **Squash failed**: ${{ steps.validate.outputs.message }}

      - name: Checkout repository
        if: steps.validate.outputs.error == 'false'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          token: ${{ secrets.CHATOPS_TOKEN }}
          fetch-depth: 0
          repository: ${{ steps.validate.outputs.head_repo_full_name }}
          ref: ${{ steps.validate.outputs.head_ref }}

      - name: Perform squash
        if: steps.validate.outputs.error == 'false'
        id: squash
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.CHATOPS_TOKEN }}
          HEAD_REF: ${{ steps.validate.outputs.head_ref }}
          BASE_REF: ${{ steps.validate.outputs.base_ref }}
          PR_NUMBER: ${{ github.event.client_payload.pull_request.number }}
          IS_FORK: ${{ steps.validate.outputs.is_fork }}
          UPSTREAM_REPO: ${{ github.repository }}
        run: |
          set -e

          OUTPUT_FILE=$(mktemp)

          {
            echo "Starting squash process..."

            git config user.name "Tekton Bot"
            git config user.email "tekton-bot@users.noreply.github.com"

            # Set up base branch access
            if [ "$IS_FORK" = "true" ]; then
              echo "Fork PR: adding upstream remote for base branch..."
              git remote add upstream "https://github.com/${UPSTREAM_REPO}.git"
              git fetch upstream "$BASE_REF"
              BASE_REMOTE="upstream"
            else
              git fetch origin "$BASE_REF" || {
                echo "ERROR: Failed to fetch base branch '$BASE_REF'"
                exit 1
              }
              BASE_REMOTE="origin"
            fi

            # Find merge base
            MERGE_BASE=$(git merge-base "${BASE_REMOTE}/${BASE_REF}" HEAD)
            echo "Merge base: $MERGE_BASE"

            # Count commits
            COMMIT_COUNT=$(git rev-list --count "$MERGE_BASE"..HEAD)
            echo "Found $COMMIT_COUNT commit(s) on branch"

            if [ "$COMMIT_COUNT" -le 1 ]; then
              echo "already_single_commit=true" >> $GITHUB_OUTPUT
              echo "Branch already has a single commit. Nothing to squash."
            else
              # Check for merge commits (warn but proceed)
              MERGE_COMMIT_COUNT=$(git rev-list --merges --count "$MERGE_BASE"..HEAD)
              if [ "$MERGE_COMMIT_COUNT" -gt 0 ]; then
                echo "has_merge_commits=true" >> $GITHUB_OUTPUT
                echo "WARNING: Branch contains $MERGE_COMMIT_COUNT merge commit(s). The squash will proceed but consider using /rebase first for cleaner history."
              else
                echo "has_merge_commits=false" >> $GITHUB_OUTPUT
              fi

              # Save the first commit's message (the "main" commit message)
              FIRST_COMMIT=$(git rev-list --reverse "$MERGE_BASE"..HEAD | head -1)
              COMMIT_MSG=$(git log -1 --format="%B" "$FIRST_COMMIT")

              # Collect unique trailers from ALL commits being squashed
              TRAILERS=""
              for KEY in "Co-authored-by" "Signed-off-by"; do
                VALS=$(git log --format="%(trailers:key=$KEY,valueonly)" "$MERGE_BASE"..HEAD | sort -u | grep -v '^$' || true)
                while IFS= read -r val; do
                  [ -n "$val" ] && TRAILERS="$TRAILERS"$'\n'"$KEY: $val"
                done <<< "$VALS"
              done

              # Perform soft reset (squash all commits into staged changes)
              git reset --soft "$MERGE_BASE"

              # Build final commit message with preserved trailers
              FULL_MSG="$COMMIT_MSG"
              if [ -n "$TRAILERS" ]; then
                FULL_MSG="$FULL_MSG"$'\n'"$TRAILERS"
              fi

              # Create single squashed commit
              git commit -m "$FULL_MSG"

              # Force push with lease (safe against concurrent pushes)
              git push --force-with-lease origin "$HEAD_REF" || {
                if [ "$IS_FORK" = "true" ]; then
                  echo "ERROR: Failed to push to fork branch. Ensure 'Allow edits from maintainers' is still enabled and no concurrent pushes occurred."
                else
                  echo "ERROR: Failed to push squashed branch. Someone may have pushed new commits."
                fi
                exit 1
              }

              echo "commits_squashed=$COMMIT_COUNT" >> $GITHUB_OUTPUT
              echo "already_single_commit=false" >> $GITHUB_OUTPUT
              echo "Squash completed successfully!"
            fi
          } 2>&1 | tee "$OUTPUT_FILE"

          EXIT_CODE=${PIPESTATUS[0]}

          # Save output for use in comments
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "output<<$EOF" >> $GITHUB_OUTPUT
          cat "$OUTPUT_FILE" >> $GITHUB_OUTPUT
          echo "$EOF" >> $GITHUB_OUTPUT

          rm -f "$OUTPUT_FILE"
          exit $EXIT_CODE

      - name: Comment on success (already single commit)
        if: steps.validate.outputs.error == 'false' && steps.squash.outcome == 'success' && steps.squash.outputs.already_single_commit == 'true'
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        with:
          token: ${{ secrets.CHATOPS_TOKEN }}
          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}
          issue-number: ${{ github.event.client_payload.github.payload.issue.number }}
          body: |
            **Already a single commit!**

            The branch `${{ steps.validate.outputs.head_ref }}` already has a single commit. Nothing to squash.

      - name: Comment on success (squashed)
        if: steps.validate.outputs.error == 'false' && steps.squash.outcome == 'success' && steps.squash.outputs.already_single_commit == 'false'
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        with:
          token: ${{ secrets.CHATOPS_TOKEN }}
          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}
          issue-number: ${{ github.event.client_payload.github.payload.issue.number }}
          body: |
            **Squash successful!**

            Squashed ${{ steps.squash.outputs.commits_squashed }} commits on branch `${{ steps.validate.outputs.head_ref }}` into a single commit using the first commit's message.

            ${{ steps.squash.outputs.has_merge_commits == 'true' && '**Note:** The branch contained merge commits. The squashed result may include changes from the base branch. Consider reviewing the diff.' || '' }}

      - name: Comment on failure
        if: steps.validate.outputs.error == 'false' && steps.squash.outcome == 'failure'
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        with:
          token: ${{ secrets.CHATOPS_TOKEN }}
          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}
          issue-number: ${{ github.event.client_payload.github.payload.issue.number }}
          body: |
            **Squash failed!**

            The squash of `${{ steps.validate.outputs.head_ref }}` failed.

            **Output:**
            ```
            ${{ steps.squash.outputs.output }}
            ```

            **Next steps:**
            - Check the [action logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details
            ${{ steps.validate.outputs.is_fork == 'true' && '- For fork PRs, ensure "Allow edits from maintainers" is enabled' || '- If there were concurrent pushes, try again with `/squash`' }}
